# failsafe.cf

body common control
{
      bundlesequence => {
                          "update",
                          "call_update"
                        };
}

body agent control
{
      skipidentify => "true";
}

bundle agent update
{

  vars:

      "cf3root"         string => "$(sys.workdir)";
      "dir_masterfiles" string => translatepath("$(cf3root)/masterfiles/$(current_branch)"), comment => "Define masterfiles path", handle => "common_def_vars_dir_masterfiles";
      "dir_inputs"      string => translatepath("$(sys.workdir)/inputs");
      "policy_servers"  slist  => { "odin.websages.com" };

    branch_deployed::
         "current_branch"  string => execresult("/bin/cat /var/lib/cfengine3/current_branch", "noshell");

    !branch_deployed::
         "current_branch"  string => "master";

  classes:
      "branch_deployed" expression => fileexists("$(sys.workdir)/current_branch");

    any::

      "have_ppkeys"
        expression => fileexists("$(sys.workdir)/ppkeys/localhost.pub"),
         handle => "bootstrap_update_classes_have_ppkeys";

      "have_update_cf"
        expression => fileexists("$(sys.inputdir)/update.cf"),
        handle => "bootstrap_update_classes_have_update_cf";

      "have_def_cf"
        expression => fileexists("$(sys.inputdir)/def.cf"),
        handle => "bootstrap_update_classes_have_def_cf";

  commands:
    !have_ppkeys::
      "$(sys.cf_key)" handle => "bootstrap_update_commands_generate_keys";

  files:

    have_ppkeys.!have_update_cf::
      "$(sys.inputdir)/update.cf"
        handle => "bootstrap_update_file_update_cf",
        copy_from => u_scp("$(dir_masterfiles)/update.cf"),
        classes => repaired("got_update_cf");

    have_ppkeys.!have_def_cf::
      "$(sys.inputdir)/def.cf"
        handle => "bootstrap_update_file_def_cf",
        copy_from => u_scp("$(dir_masterfiles)/def.cf"),
        classes => repaired("got_def_cf");

  reports:

    got_update_cf::
      "Updated update.cf from policy server" handle => "bootstrap_update_reports_got_update_cf";

    got_def_cf::
      "Updated def.cf from policy server" handle => "bootstrap_update_reports_got_def_cf";

    !(have_update_cf|got_update_cf)|!(have_def_cf|got_def_cf).have_ppkeys::
      "Failed to copy update.cf and def.cf from $(policy_servers):$(dir_masterfiles)
       Please check
       * cf-serverd is running on $(policy_servers)
       * network connectivity to $(policy_servers) on port 5308
       * masterfiles 'body server control' - in particular allowconnects, trustkeysfrom and skipverify
       * masterfiles 'bundle server' -> access: -> masterfiles -> admit/deny
       It is often useful to restart cf-serverd in verbose mode (cf-serverd -vvF) on $(policy_servers) to diagnose connection issues.
       When updating masterfiles, wait (usually 5 minutes) for files to propagate to inputs on $(policy_servers) before retrying."
      handle => "bootstrap_update_reports_did_not_get_update_def";

}

bundle agent call_update
{
  commands:
 "$(sys.cf_agent) -f update.cf" handle => "call_update_commands_call_update_cf";
}

body classes repaired(x)       { promise_repaired => {"$(x)"}; }
body classes kept_or_repaired(x) {
                                   promise_repaired => {"$(x)"};
                                   promise_kept     => {"$(x)"};
                                 }
body perms u_p(p)              { mode  => "$(p)"; }
body copy_from u_scp(from)     {
                                 source => "$(from)";
                                 compare     => "digest";
                                 trustkey    => "true";
                                 !am_policy_hub::
                                   servers => { "$(policy_servers)" };
                               }
body action u_background       { background => "true"; }
body depth_search u_recurse(d) { depth => "$(d)"; exclude_dirs => { "\.svn", "\.git" }; }
body service_method bootstart  { service_autostart_policy => "boot_time"; }
body copy_from u_cp(from)      {
                                 source      => "$(from)";
                                 compare     => "digest";
                                 copy_backup => "false";
                               }
